<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E-QBNN ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #0a0a2a 100%);
            color: #e0e0ff;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            padding: 30px 0;
            background: linear-gradient(180deg, rgba(100,100,255,0.1) 0%, transparent 100%);
            border-bottom: 1px solid rgba(100,100,255,0.3);
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 2.5em;
            background: linear-gradient(90deg, #6af, #f6a, #6af);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #8888cc;
            font-size: 1.1em;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        @media (max-width: 1000px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .panel {
            background: rgba(30, 30, 60, 0.8);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(100,100,255,0.2);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .panel-title {
            font-size: 1.3em;
            color: #aaf;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(100,100,255,0.2);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .panel-title::before {
            content: 'âš›ï¸';
        }
        
        /* ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å¯è¦–åŒ– */
        #network-canvas {
            width: 100%;
            height: 300px;
            background: rgba(0,0,20,0.5);
            border-radius: 10px;
        }
        
        /* Blochçƒ */
        #bloch-canvas {
            width: 100%;
            height: 300px;
            background: rgba(0,0,20,0.5);
            border-radius: 10px;
        }
        
        /* r-Tå¹³é¢ */
        #rt-canvas {
            width: 100%;
            height: 250px;
            background: rgba(0,0,20,0.5);
            border-radius: 10px;
        }
        
        /* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« */
        .controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 15px;
        }
        
        .control-group {
            background: rgba(0,0,30,0.5);
            padding: 12px;
            border-radius: 8px;
        }
        
        .control-group label {
            display: block;
            font-size: 0.9em;
            color: #88a;
            margin-bottom: 5px;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin-top: 5px;
        }
        
        .control-group .value {
            text-align: right;
            color: #6af;
            font-family: monospace;
        }
        
        /* çµ±è¨ˆãƒ‘ãƒãƒ« */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        
        .stat-box {
            background: rgba(0,0,40,0.5);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-box .label {
            font-size: 0.8em;
            color: #88a;
        }
        
        .stat-box .value {
            font-size: 1.5em;
            font-family: monospace;
            color: #6f6;
        }
        
        /* ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ± */
        .layer-info {
            margin-top: 15px;
        }
        
        .layer-row {
            display: grid;
            grid-template-columns: 80px 1fr 1fr 1fr 1fr;
            gap: 10px;
            padding: 8px;
            background: rgba(0,0,40,0.3);
            border-radius: 5px;
            margin-bottom: 5px;
            font-family: monospace;
            font-size: 0.9em;
        }
        
        .layer-row.header {
            color: #88a;
            font-weight: bold;
        }
        
        /* ç”Ÿæˆãƒ‘ãƒãƒ« */
        .generate-section {
            margin-top: 20px;
        }
        
        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .input-group input {
            flex: 1;
            padding: 12px 15px;
            border: none;
            border-radius: 8px;
            background: rgba(0,0,40,0.8);
            color: #fff;
            font-size: 1em;
        }
        
        .input-group input:focus {
            outline: 2px solid #6af;
        }
        
        button {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #4466ff, #6644ff);
            color: white;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(100,100,255,0.4);
        }
        
        .output-box {
            background: rgba(0,0,40,0.5);
            padding: 15px;
            border-radius: 8px;
            min-height: 100px;
            font-family: monospace;
            line-height: 1.6;
            white-space: pre-wrap;
        }
        
        /* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .quantum-active {
            animation: pulse 1s infinite;
        }
        
        /* ã‚¨ãƒ³ãƒ™ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤º */
        .embedding-section {
            margin-top: 15px;
        }
        
        .embedding-display {
            background: rgba(0,0,40,0.5);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }
        
        .embedding-info {
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        
        .highlight-text {
            color: #f6a;
            font-weight: bold;
        }
        
        .embedding-vector-title {
            color: #88a;
            font-size: 0.9em;
            margin-bottom: 10px;
        }
        
        #embedding-canvas {
            width: 100%;
            height: 80px;
            background: rgba(0,0,20,0.5);
            border-radius: 5px;
        }
        
        .embedding-values {
            font-family: monospace;
            color: #6af;
            font-size: 0.85em;
            margin-top: 10px;
            word-break: break-all;
        }
        
        .token-display {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 15px;
        }
        
        .token-chip {
            background: linear-gradient(135deg, #335, #446);
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 1px solid rgba(100,100,255,0.3);
        }
        
        .token-chip .char {
            color: #fff;
            font-weight: bold;
        }
        
        .token-chip .id {
            color: #6af;
            font-size: 0.8em;
        }
        
        .token-chip .vec {
            color: #6f6;
            font-size: 0.7em;
        }
        
        /* æ•°å¼è¡¨ç¤º */
        .formula {
            background: rgba(0,0,40,0.5);
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            text-align: center;
            margin: 10px 0;
            color: #aaf;
        }
        
        .formula .highlight {
            color: #6f6;
            font-size: 1.2em;
        }
        
        /* é‡å­çŠ¶æ…‹è¡¨ç¤º */
        .quantum-state {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 15px 0;
        }
        
        .state-component {
            text-align: center;
            padding: 15px;
            background: rgba(0,0,40,0.5);
            border-radius: 8px;
            min-width: 100px;
        }
        
        .state-component .ket {
            font-size: 1.5em;
            color: #f6a;
        }
        
        .state-component .amplitude {
            font-family: monospace;
            color: #6af;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <header>
        <h1>ğŸ§ âš›ï¸ E-QBNN ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</h1>
        <p class="subtitle">Entangled Quantum Bit Neural Network - å±¤é–“ã‚¨ãƒ³ã‚¿ãƒ³ã‚°ãƒ«ãƒ¡ãƒ³ãƒˆã‚’æŒã¤é‡å­ãƒ‹ãƒ¥ãƒ¼ãƒ©ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯</p>
    </header>
    
    <div class="container">
        <div class="main-grid">
            <!-- å·¦ã‚«ãƒ©ãƒ  -->
            <div>
                <!-- ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ§‹é€  -->
                <div class="panel">
                    <div class="panel-title">ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ§‹é€ </div>
                    <canvas id="network-canvas"></canvas>
                    
                    <div class="controls">
                        <div class="control-group">
                            <label>éš ã‚Œå±¤ã®æ•°</label>
                            <input type="range" id="num-layers" min="1" max="5" value="3">
                            <div class="value" id="num-layers-val">3</div>
                        </div>
                        <div class="control-group">
                            <label>ã‚¨ãƒ³ã‚¿ãƒ³ã‚°ãƒ«ãƒ¡ãƒ³ãƒˆå¼·åº¦ (Î»)</label>
                            <input type="range" id="entangle-strength" min="0" max="100" value="50">
                            <div class="value" id="entangle-val">0.50</div>
                        </div>
                    </div>
                </div>
                
                <!-- r-Tå¹³é¢ -->
                <div class="panel" style="margin-top: 20px;">
                    <div class="panel-title">r-T å¹³é¢ (å¹¾ä½•å­¦çš„åˆ¶ç´„)</div>
                    <canvas id="rt-canvas"></canvas>
                    
                    <div class="formula">
                        åˆ¶ç´„æ¡ä»¶: <span class="highlight">rÂ² + TÂ² = 1</span>
                        <br>
                        r = cos(2Î¸), T = |sin(2Î¸)|
                    </div>
                </div>
            </div>
            
            <!-- å³ã‚«ãƒ©ãƒ  -->
            <div>
                <!-- Blochçƒ -->
                <div class="panel">
                    <div class="panel-title">Blochçƒ (é‡å­çŠ¶æ…‹)</div>
                    <canvas id="bloch-canvas"></canvas>
                    
                    <div class="quantum-state">
                        <div class="state-component">
                            <div class="ket">|0âŸ©</div>
                            <div class="amplitude" id="amp-0">cos(Î¸) = 0.707</div>
                        </div>
                        <div class="state-component">
                            <div class="ket">|ÏˆâŸ© =</div>
                            <div class="amplitude">cos(Î¸)|0âŸ© + sin(Î¸)|1âŸ©</div>
                        </div>
                        <div class="state-component">
                            <div class="ket">|1âŸ©</div>
                            <div class="amplitude" id="amp-1">sin(Î¸) = 0.707</div>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>é¸æŠãƒ¬ã‚¤ãƒ¤ãƒ¼</label>
                        <input type="range" id="selected-layer" min="0" max="2" value="0">
                        <div class="value" id="selected-layer-val">Layer 0</div>
                    </div>
                </div>
                
                <!-- å±¤ã”ã¨ã®çµ±è¨ˆ -->
                <div class="panel" style="margin-top: 20px;">
                    <div class="panel-title">ãƒ¬ã‚¤ãƒ¤ãƒ¼çµ±è¨ˆ</div>
                    
                    <div class="stats-grid">
                        <div class="stat-box">
                            <div class="label">ç·åˆ¶ç´„èª¤å·®</div>
                            <div class="value" id="total-constraint">0.0000</div>
                        </div>
                        <div class="stat-box">
                            <div class="label">å¹³å‡ r</div>
                            <div class="value" id="avg-r">0.000</div>
                        </div>
                        <div class="stat-box">
                            <div class="label">å¹³å‡ T</div>
                            <div class="value" id="avg-T">0.000</div>
                        </div>
                    </div>
                    
                    <div class="layer-info">
                        <div class="layer-row header">
                            <span>Layer</span>
                            <span>Î¸</span>
                            <span>r</span>
                            <span>T</span>
                            <span>rÂ²+TÂ²</span>
                        </div>
                        <div id="layer-rows"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ³ãƒ™ãƒ‡ã‚£ãƒ³ã‚° -->
        <div class="panel" style="margin-top: 20px;">
            <div class="panel-title">ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ³ãƒ™ãƒ‡ã‚£ãƒ³ã‚°å…¥åŠ›</div>
            
            <div class="embedding-section">
                <div class="input-group">
                    <input type="text" id="embedding-input" placeholder="ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ› (ä¾‹: é‡å­)" value="é‡å­">
                    <button onclick="computeEmbedding()">ã‚¨ãƒ³ãƒ™ãƒ‡ã‚£ãƒ³ã‚°è¨ˆç®—</button>
                </div>
                
                <div class="embedding-display">
                    <div class="embedding-info">
                        <span>å…¥åŠ›ãƒ†ã‚­ã‚¹ãƒˆ: </span>
                        <span id="input-text-display" class="highlight-text">é‡å­</span>
                        <span> â†’ </span>
                        <span id="token-count">2</span>
                        <span> ãƒˆãƒ¼ã‚¯ãƒ³</span>
                    </div>
                    
                    <div class="embedding-vector-title">ã‚¨ãƒ³ãƒ™ãƒ‡ã‚£ãƒ³ã‚°ãƒ™ã‚¯ãƒˆãƒ« (8æ¬¡å…ƒ)</div>
                    <canvas id="embedding-canvas"></canvas>
                    
                    <div class="embedding-values" id="embedding-values">
                        [0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000]
                    </div>
                </div>
                
                <div class="token-display" id="token-display">
                    <!-- ãƒˆãƒ¼ã‚¯ãƒ³ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã‚‹ -->
                </div>
            </div>
        </div>
        
        <!-- ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆ -->
        <div class="panel" style="margin-top: 20px;">
            <div class="panel-title">é‡å­ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆ</div>
            
            <div class="generate-section">
                <div class="input-group">
                    <input type="text" id="prompt-input" placeholder="ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å…¥åŠ› (ä¾‹: é‡å­ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã¯)">
                    <button onclick="generateText()">ç”Ÿæˆ</button>
                </div>
                
                <div class="controls" style="margin-bottom: 15px;">
                    <div class="control-group">
                        <label>æ¸©åº¦ (Temperature)</label>
                        <input type="range" id="temperature" min="10" max="200" value="100">
                        <div class="value" id="temp-val">1.00</div>
                    </div>
                    <div class="control-group">
                        <label>ç”Ÿæˆé•·ã•</label>
                        <input type="range" id="gen-length" min="10" max="100" value="40">
                        <div class="value" id="len-val">40</div>
                    </div>
                </div>
                
                <div class="output-box" id="output-box">ç”ŸæˆçµæœãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™...</div>
            </div>
        </div>
    </div>
    
    <script>
        // ========================================
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å®šæ•°
        // ========================================
        const EMBED_DIM = 8;  // ã‚¨ãƒ³ãƒ™ãƒ‡ã‚£ãƒ³ã‚°æ¬¡å…ƒ
        let currentEmbedding = new Array(EMBED_DIM).fill(0);
        
        // ========================================
        // APQB ã‚³ã‚¢é–¢æ•°
        // ========================================
        
        class APQB {
            static thetaToR(theta) {
                return Math.cos(2 * theta);
            }
            
            static thetaToT(theta) {
                return Math.abs(Math.sin(2 * theta));
            }
            
            static constraint(theta) {
                const r = this.thetaToR(theta);
                const T = this.thetaToT(theta);
                return r * r + T * T;
            }
            
            static measure(theta) {
                const p1 = Math.sin(theta) ** 2;
                return Math.random() < p1 ? 1 : 0;
            }
        }
        
        // ========================================
        // E-QBNN ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        // ========================================
        
        // ========================================
        // QBNN æ•°å¼ãƒ¢ãƒ‡ãƒ«å®Ÿè£…
        // ========================================
        
        class QBNNLayer {
            /**
             * QBNN Layer
             * 
             * æ•°å¼ãƒ¢ãƒ‡ãƒ«:
             * 1. s^(l) = normalize(h^(l)) âˆˆ [-1,1]  (æ­£è¦åŒ–)
             * 2. Î¸^(l)_i = arccos(s^(l)_i)          (Blochè§’)
             * 3. Î”^(l+1)_j = Î£_i J_{ij} s^(l)_i s^(l+1)_{raw,j}  (ã‚‚ã¤ã‚Œè£œæ­£)
             * 4. Ä¥^(l+1) = hÌƒ^(l+1) + Î» Î”^(l+1)    (æœ‰åŠ¹å…¥åŠ›)
             * 5. h^(l+1) = Ïƒ(Ä¥^(l+1))              (æ´»æ€§åŒ–)
             */
            constructor(inputDim, outputDim, lambda = 0.5) {
                this.inputDim = inputDim;
                this.outputDim = outputDim;
                this.lambda = lambda;  // ã‚‚ã¤ã‚Œå¼·ã•
                
                // é‡ã¿ W^(l)
                this.W = this.initWeight(inputDim, outputDim);
                // ãƒã‚¤ã‚¢ã‚¹ b^(l)
                this.b = new Array(outputDim).fill(0).map(() => (Math.random() - 0.5) * 0.1);
                // ã‚‚ã¤ã‚Œãƒ†ãƒ³ã‚½ãƒ« J^(l)
                this.J = this.initWeight(inputDim, outputDim);
                
                // çŠ¶æ…‹ä¿æŒ
                this.s = null;      // æ­£è¦åŒ–ã•ã‚ŒãŸçŠ¶æ…‹ [-1,1]
                this.theta = null;  // Blochè§’
                this.h = null;      // å‡ºåŠ›
            }
            
            initWeight(rows, cols) {
                const scale = Math.sqrt(2 / (rows + cols));
                return Array(rows).fill(0).map(() => 
                    Array(cols).fill(0).map(() => (Math.random() - 0.5) * scale * 2)
                );
            }
            
            normalize(h) {
                // h ã‚’ [-1, 1] ã«æ­£è¦åŒ–ï¼ˆtanhçš„ï¼‰
                return h.map(v => Math.tanh(v));
            }
            
            forward(h_prev) {
                // Step 1: å‰ã®å±¤ã®æ­£è¦åŒ– s^(l)
                const s_prev = this.normalize(h_prev);
                
                // Step 2: Blochè§’ Î¸^(l)
                const theta_prev = s_prev.map(s => Math.acos(Math.max(-1, Math.min(1, s))));
                
                // Step 3: ç·šå½¢å¤‰æ› hÌƒ^(l+1) = W h^(l) + b
                const h_tilde = new Array(this.outputDim).fill(0);
                for (let j = 0; j < this.outputDim; j++) {
                    let sum = this.b[j];
                    for (let i = 0; i < this.inputDim; i++) {
                        sum += this.W[i][j] * h_prev[i];
                    }
                    h_tilde[j] = sum;
                }
                
                // Step 4: æ­£è¦åŒ–ï¼ˆç”Ÿã®å€™è£œï¼‰s^(l+1)_raw
                const s_raw = this.normalize(h_tilde);
                
                // Step 5: ã‚‚ã¤ã‚Œè£œæ­£ Î”^(l+1)
                const delta = new Array(this.outputDim).fill(0);
                for (let j = 0; j < this.outputDim; j++) {
                    let sum = 0;
                    for (let i = 0; i < this.inputDim; i++) {
                        // Î”_j = Î£_i J_{ij} s^(l)_i s^(l+1)_{raw,j}
                        sum += this.J[i][j] * s_prev[i] * s_raw[j];
                    }
                    delta[j] = sum;
                }
                
                // Step 6: æœ‰åŠ¹å…¥åŠ› Ä¥^(l+1) = hÌƒ^(l+1) + Î» Î”^(l+1)
                const h_hat = h_tilde.map((v, j) => v + this.lambda * delta[j]);
                
                // Step 7: æ´»æ€§åŒ– h^(l+1) = Ïƒ(Ä¥^(l+1))
                this.h = h_hat.map(v => Math.tanh(v));
                
                // çŠ¶æ…‹ä¿å­˜
                this.s = this.normalize(this.h);
                this.theta = this.s.map(s => Math.acos(Math.max(-1, Math.min(1, s))));
                
                return this.h;
            }
            
            // é‡å­æ¸¬å®š
            measure() {
                if (!this.theta) return [];
                return this.theta.map(t => {
                    const p1 = Math.sin(t / 2) ** 2;
                    return Math.random() < p1 ? 1 : 0;
                });
            }
        }
        
        class QBNN {
            /**
             * Quantum-Bit Neural Network
             * 
             * å„å±¤ãƒ»å„ãƒ“ãƒƒãƒˆãŒåˆ†å­ã®ã‚ˆã†ã«ã‚‚ã¤ã‚Œåˆã£ãŸãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯
             */
            constructor(layerDims, lambda = 0.5) {
                this.layerDims = layerDims;  // [input, hidden1, hidden2, ..., output]
                this.lambda = lambda;
                this.layers = [];
                
                // ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½œæˆ
                for (let i = 0; i < layerDims.length - 1; i++) {
                    this.layers.push(new QBNNLayer(
                        layerDims[i], 
                        layerDims[i + 1],
                        lambda * (1 - i * 0.1)  // æ·±ã„å±¤ã»ã©å¼±ã
                    ));
                }
                
                // äº’æ›æ€§ã®ãŸã‚
                this.numLayers = this.layers.length;
                this.entangleStrength = lambda;
            }
            
            forward(input) {
                let h = input;
                for (const layer of this.layers) {
                    h = layer.forward(h);
                }
                return h;
            }
            
            // å…¨å±¤ã®æ¸¬å®šçµæœ
            measureAll() {
                return this.layers.map(layer => layer.measure());
            }
            
            getStats() {
                let totalConstraint = 0;
                let avgR = 0;
                let avgT = 0;
                let count = 0;
                
                for (const layer of this.layers) {
                    if (layer.s) {
                        for (const s of layer.s) {
                            const theta = Math.acos(Math.max(-1, Math.min(1, s)));
                            const r = APQB.thetaToR(theta);
                            const T = APQB.thetaToT(theta);
                            avgR += r;
                            avgT += T;
                            totalConstraint += Math.abs(r*r + T*T - 1);
                            count++;
                        }
                    }
                }
                
                return {
                    totalConstraint: count > 0 ? totalConstraint / count : 0,
                    avgR: count > 0 ? avgR / count : 0,
                    avgT: count > 0 ? avgT / count : 0
                };
            }
        }
        
        // å¤ã„EQBNNã¨ã®äº’æ›æ€§ãƒ©ãƒƒãƒ‘ãƒ¼
        class EQBNN {
            constructor(numLayers = 3, entangleStrength = 0.5) {
                this.numLayers = numLayers;
                this.entangleStrength = entangleStrength;
                
                // QBNN ã‚’å†…éƒ¨ã§ä½¿ç”¨
                const embedDim = typeof EMBED_DIM !== 'undefined' ? EMBED_DIM : 8;
                const dims = [embedDim];
                for (let i = 0; i < numLayers; i++) {
                    dims.push(4);  // å„éš ã‚Œå±¤4ãƒ¦ãƒ‹ãƒƒãƒˆ
                }
                dims.push(2);  // å‡ºåŠ›2ãƒ¦ãƒ‹ãƒƒãƒˆ
                
                this.qbnn = new QBNN(dims, entangleStrength);
                this.layers = [];
                this.initializeLayers();
            }
            
            initializeLayers() {
                this.layers = [];
                const thetaMin = Math.PI / 8;
                const thetaMax = 3 * Math.PI / 8;
                
                for (let i = 0; i < this.numLayers; i++) {
                    const theta = thetaMin + Math.random() * (thetaMax - thetaMin);
                    this.layers.push({
                        theta: theta,
                        r: APQB.thetaToR(theta),
                        T: APQB.thetaToT(theta),
                        entangleStrength: this.entangleStrength * (1 - i * 0.05),
                        s: null,
                        measurements: null
                    });
                }
            }
            
            forward(input) {
                // å…¥åŠ›ãŒãªã„å ´åˆã¯ã‚¨ãƒ³ãƒ™ãƒ‡ã‚£ãƒ³ã‚°ã‚’ä½¿ç”¨
                if (!input) {
                    input = currentEmbedding;
                }
                
                // QBNN ã§ãƒ•ã‚©ãƒ¯ãƒ¼ãƒ‰
                this.qbnn.forward(input);
                
                // å„å±¤ã®çŠ¶æ…‹ã‚’æ›´æ–°
                const thetaMin = Math.PI / 8;
                const thetaMax = 3 * Math.PI / 8;
                
                for (let i = 0; i < this.numLayers && i < this.qbnn.layers.length; i++) {
                    const qbnnLayer = this.qbnn.layers[i];
                    if (qbnnLayer.s && qbnnLayer.s.length > 0) {
                        // å¹³å‡Î¸ã‚’è¨ˆç®—
                        const avgS = qbnnLayer.s.reduce((a, b) => a + b, 0) / qbnnLayer.s.length;
                        const theta = Math.acos(Math.max(-1, Math.min(1, avgS)));
                        
                        this.layers[i].theta = Math.max(thetaMin, Math.min(thetaMax, theta));
                        this.layers[i].r = APQB.thetaToR(this.layers[i].theta);
                        this.layers[i].T = APQB.thetaToT(this.layers[i].theta);
                        this.layers[i].s = qbnnLayer.s;
                        this.layers[i].measurements = qbnnLayer.measure();
                    }
                }
            }
            
            getStats() {
                return this.qbnn.getStats();
            }
        }
        
        // ========================================
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        // ========================================
        
        let qbnn = new EQBNN(3, 0.5);
        let selectedLayerIndex = 0;
        let animationId = null;
        
        // ========================================
        // ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ³ãƒ™ãƒ‡ã‚£ãƒ³ã‚°
        // ========================================
        
        class TextEmbedding {
            constructor(dim = 8) {
                this.dim = dim;
                this.charToId = {};
                this.idToChar = {};
                this.embeddings = {};
                this.nextId = 0;
                
                // åŸºæœ¬æ–‡å­—ã®ã‚¨ãƒ³ãƒ™ãƒ‡ã‚£ãƒ³ã‚°ã‚’åˆæœŸåŒ–
                this.initializeBaseEmbeddings();
            }
            
            initializeBaseEmbeddings() {
                // ã‚ˆãä½¿ã†æ–‡å­—ã«å›ºå®šã‚¨ãƒ³ãƒ™ãƒ‡ã‚£ãƒ³ã‚°ã‚’å‰²ã‚Šå½“ã¦
                const baseChars = 'é‡å­ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã¯ãƒ‹ãƒ¥ãƒ¼ãƒ©ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ©Ÿæ¢°å­¦ç¿’äººå·¥çŸ¥èƒ½æ·±å±¤è‡ªç„¶è¨€èªå‡¦ç†abcdefghijklmnopqrstuvwxyz0123456789';
                
                for (const char of baseChars) {
                    this.getOrCreateEmbedding(char);
                }
            }
            
            getOrCreateEmbedding(char) {
                if (!(char in this.charToId)) {
                    this.charToId[char] = this.nextId;
                    this.idToChar[this.nextId] = char;
                    
                    // æ–‡å­—ã®Unicodeã‚’ä½¿ã£ã¦æ“¬ä¼¼ãƒ©ãƒ³ãƒ€ãƒ ãªã‚¨ãƒ³ãƒ™ãƒ‡ã‚£ãƒ³ã‚°ã‚’ç”Ÿæˆ
                    const code = char.charCodeAt(0);
                    const embedding = [];
                    
                    for (let i = 0; i < this.dim; i++) {
                        // ã‚·ãƒ¼ãƒ‰ä»˜ãç–‘ä¼¼ä¹±æ•°ï¼ˆå†ç¾å¯èƒ½ï¼‰
                        const seed = code * 31 + i * 17;
                        const val = Math.sin(seed) * Math.cos(seed * 0.7);
                        embedding.push(val);
                    }
                    
                    // æ­£è¦åŒ–
                    const norm = Math.sqrt(embedding.reduce((s, v) => s + v * v, 0));
                    this.embeddings[char] = embedding.map(v => v / (norm + 0.001));
                    
                    this.nextId++;
                }
                
                return {
                    id: this.charToId[char],
                    embedding: this.embeddings[char]
                };
            }
            
            encode(text) {
                const tokens = [];
                for (const char of text) {
                    tokens.push(this.getOrCreateEmbedding(char));
                }
                return tokens;
            }
            
            // ãƒ†ã‚­ã‚¹ãƒˆå…¨ä½“ã®ã‚¨ãƒ³ãƒ™ãƒ‡ã‚£ãƒ³ã‚°ï¼ˆå¹³å‡ï¼‰
            getTextEmbedding(text) {
                const tokens = this.encode(text);
                if (tokens.length === 0) {
                    return new Array(this.dim).fill(0);
                }
                
                const sumEmbedding = new Array(this.dim).fill(0);
                
                for (const token of tokens) {
                    for (let i = 0; i < this.dim; i++) {
                        sumEmbedding[i] += token.embedding[i];
                    }
                }
                
                // å¹³å‡
                return sumEmbedding.map(v => v / tokens.length);
            }
            
            // ä½ç½®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ä»˜ãã‚¨ãƒ³ãƒ™ãƒ‡ã‚£ãƒ³ã‚°
            getPositionalEmbedding(text) {
                const tokens = this.encode(text);
                const embeddings = [];
                
                for (let pos = 0; pos < tokens.length; pos++) {
                    const baseEmbed = [...tokens[pos].embedding];
                    
                    // ä½ç½®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’è¿½åŠ 
                    for (let i = 0; i < this.dim; i++) {
                        const angle = pos / Math.pow(10000, 2 * i / this.dim);
                        if (i % 2 === 0) {
                            baseEmbed[i] += Math.sin(angle) * 0.1;
                        } else {
                            baseEmbed[i] += Math.cos(angle) * 0.1;
                        }
                    }
                    
                    embeddings.push({
                        char: tokens[pos].embedding,
                        id: tokens[pos].id,
                        position: pos,
                        embedding: baseEmbed
                    });
                }
                
                return embeddings;
            }
        }
        
        const textEmbedder = new TextEmbedding(EMBED_DIM);
        
        function computeEmbedding() {
            const input = document.getElementById('embedding-input').value || 'é‡å­';
            
            // ãƒˆãƒ¼ã‚¯ãƒ³åŒ–ã¨ã‚¨ãƒ³ãƒ™ãƒ‡ã‚£ãƒ³ã‚°
            const tokens = textEmbedder.encode(input);
            const textEmbedding = textEmbedder.getTextEmbedding(input);
            
            currentEmbedding = textEmbedding;
            
            // è¡¨ç¤ºæ›´æ–°
            document.getElementById('input-text-display').textContent = input;
            document.getElementById('token-count').textContent = tokens.length;
            
            // ã‚¨ãƒ³ãƒ™ãƒ‡ã‚£ãƒ³ã‚°å€¤è¡¨ç¤º
            const embStr = textEmbedding.map(v => v.toFixed(3)).join(', ');
            document.getElementById('embedding-values').textContent = `[${embStr}]`;
            
            // ãƒˆãƒ¼ã‚¯ãƒ³è¡¨ç¤º
            const tokenDisplay = document.getElementById('token-display');
            tokenDisplay.innerHTML = '';
            
            tokens.forEach((token, i) => {
                const chip = document.createElement('div');
                chip.className = 'token-chip';
                
                const char = input[i];
                const vecPreview = token.embedding.slice(0, 3).map(v => v.toFixed(2)).join(',');
                
                chip.innerHTML = `
                    <span class="char">${char}</span>
                    <span class="id">ID:${token.id}</span>
                    <span class="vec">[${vecPreview}...]</span>
                `;
                tokenDisplay.appendChild(chip);
            });
            
            // ã‚¨ãƒ³ãƒ™ãƒ‡ã‚£ãƒ³ã‚°ã‚’å¯è¦–åŒ–
            drawEmbedding(textEmbedding);
            
            // QBNNã«ã‚¨ãƒ³ãƒ™ãƒ‡ã‚£ãƒ³ã‚°ã‚’å…¥åŠ›
            feedEmbeddingToQBNN(textEmbedding);
        }
        
        function drawEmbedding(embedding) {
            const canvas = document.getElementById('embedding-canvas');
            const ctx = canvas.getContext('2d');
            
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * 2;
            canvas.height = rect.height * 2;
            ctx.scale(2, 2);
            
            const width = rect.width;
            const height = rect.height;
            
            // èƒŒæ™¯
            ctx.fillStyle = 'rgba(0, 0, 20, 0.5)';
            ctx.fillRect(0, 0, width, height);
            
            const barWidth = width / (embedding.length + 1);
            const centerY = height / 2;
            const maxHeight = height / 2 - 10;
            
            // ä¸­å¤®ç·š
            ctx.strokeStyle = 'rgba(100, 100, 150, 0.3)';
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();
            
            // å„æ¬¡å…ƒã®ãƒãƒ¼
            embedding.forEach((val, i) => {
                const x = barWidth * (i + 0.5);
                const barHeight = val * maxHeight;
                
                // è‰²ï¼ˆæ­£:ç·‘ã€è² :èµ¤ï¼‰
                const color = val >= 0 ? 
                    `rgba(100, 255, 150, ${0.5 + Math.abs(val) * 0.5})` :
                    `rgba(255, 100, 100, ${0.5 + Math.abs(val) * 0.5})`;
                
                ctx.fillStyle = color;
                
                if (val >= 0) {
                    ctx.fillRect(x - barWidth * 0.3, centerY - barHeight, barWidth * 0.6, barHeight);
                } else {
                    ctx.fillRect(x - barWidth * 0.3, centerY, barWidth * 0.6, -barHeight);
                }
                
                // æ¬¡å…ƒãƒ©ãƒ™ãƒ«
                ctx.fillStyle = '#888';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`d${i}`, x, height - 5);
            });
        }
        
        function feedEmbeddingToQBNN(embedding) {
            // ã‚¨ãƒ³ãƒ™ãƒ‡ã‚£ãƒ³ã‚°ã‚’QBNNã«å…¥åŠ›ã—ã¦ãƒ•ã‚©ãƒ¯ãƒ¼ãƒ‰ãƒ‘ã‚¹å®Ÿè¡Œ
            qbnn.forward(embedding);
            
            // æ¸¬å®šçµæœã‚’æ›´æ–°
            measureAllNeurons();
            
            // UIæ›´æ–°
            updateUI();
            drawNetwork();
            drawBlochSphere();
            drawRTPlane();
        }
        
        // å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ï¼ˆç°¡æ˜“ç‰ˆï¼‰
        const vocabulary = [
            'é‡å­', 'ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿', 'ã¯', 'ã€', 'é‡å­åŠ›å­¦', 'ã®', 'åŸç†', 'ã‚’', 'åˆ©ç”¨', 'ã—ã¦',
            'æƒ…å ±', 'å‡¦ç†', 'ã™ã‚‹', 'é©æ–°çš„', 'ãª', 'è¨ˆç®—æ©Ÿ', 'ã§ã™', 'ã€‚',
            'ãƒ‹ãƒ¥ãƒ¼ãƒ©ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯', 'äººé–“', 'è„³', 'ç¥çµŒå›è·¯', 'æ¨¡å€£', 'ã—ãŸ', 'è¨ˆç®—ã‚·ã‚¹ãƒ†ãƒ ',
            'æ©Ÿæ¢°å­¦ç¿’', 'æ˜ç¤ºçš„', 'ãƒ—ãƒ­ã‚°ãƒ©ãƒ ', 'ãƒ‡ãƒ¼ã‚¿', 'ã‹ã‚‰', 'å­¦ç¿’', 'æ”¹å–„',
            'äººå·¥çŸ¥èƒ½', 'æ·±å±¤å­¦ç¿’', 'å¤šå±¤', 'ç‰¹å¾´', 'è‡ªå‹•çš„', 'ç”»åƒèªè­˜', 'éŸ³å£°èªè­˜',
            'æˆåŠŸ', 'åã‚ã¦', 'ã„ã¾ã™', 'æŠ€è¡“', 'æœªæ¥', 'å¯èƒ½æ€§', 'ç„¡é™', 'å¤§ããª',
            'æ³¨æ„æ©Ÿæ§‹', 'å…¥åŠ›', 'é‡è¦', 'éƒ¨åˆ†', 'ç„¦ç‚¹', 'å½“ã¦ã‚‹', 'å“è³ª', 'å‘ä¸Š'
        ];
        
        // ========================================
        // Canvas æç”»
        // ========================================
        
        // ãƒ‹ãƒ¥ãƒ¼ãƒ­ãƒ³ã®æ¸¬å®šçµæœã‚’ä¿æŒ
        let neuronMeasurements = [];
        
        function measureAllNeurons() {
            neuronMeasurements = [];
            const numLayers = qbnn.numLayers + 2;
            const embedDim = typeof EMBED_DIM !== 'undefined' ? EMBED_DIM : 8;
            const neuronsPerLayer = [embedDim, ...Array(qbnn.numLayers).fill(4), 2];
            
            // å…¥åŠ›å±¤ï¼šã‚¨ãƒ³ãƒ™ãƒ‡ã‚£ãƒ³ã‚°ã‹ã‚‰æ¸¬å®š
            const inputMeasurements = [];
            for (let i = 0; i < neuronsPerLayer[0]; i++) {
                const embedVal = currentEmbedding[i] || 0;
                const theta = Math.PI / 4 + embedVal * Math.PI / 8;
                inputMeasurements.push(APQB.measure(theta));
            }
            neuronMeasurements.push(inputMeasurements);
            
            // éš ã‚Œå±¤ï¼šQBNNã®æ¸¬å®šçµæœã‚’ä½¿ç”¨
            for (let l = 0; l < qbnn.numLayers; l++) {
                const layer = qbnn.layers[l];
                if (layer.measurements && layer.measurements.length > 0) {
                    neuronMeasurements.push([...layer.measurements]);
                } else {
                    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                    const measurements = [];
                    for (let i = 0; i < neuronsPerLayer[l + 1]; i++) {
                        const theta = layer.theta || Math.PI / 4;
                        measurements.push(APQB.measure(theta));
                    }
                    neuronMeasurements.push(measurements);
                }
            }
            
            // å‡ºåŠ›å±¤
            const outputMeasurements = [];
            const lastLayer = qbnn.layers[qbnn.numLayers - 1];
            for (let i = 0; i < neuronsPerLayer[numLayers - 1]; i++) {
                const theta = lastLayer ? lastLayer.theta : Math.PI / 4;
                outputMeasurements.push(APQB.measure(theta));
            }
            neuronMeasurements.push(outputMeasurements);
        }
        
        function drawNetwork() {
            const canvas = document.getElementById('network-canvas');
            const ctx = canvas.getContext('2d');
            
            // Retinaå¯¾å¿œ
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * 2;
            canvas.height = rect.height * 2;
            ctx.scale(2, 2);
            
            const width = rect.width;
            const height = rect.height;
            
            // èƒŒæ™¯ã‚¯ãƒªã‚¢
            ctx.fillStyle = 'rgba(0, 0, 20, 0.5)';
            ctx.fillRect(0, 0, width, height);
            
            const numLayers = qbnn.numLayers + 2; // å…¥åŠ› + éš ã‚Œå±¤ + å‡ºåŠ›
            const layerSpacing = width / (numLayers + 1);
            const embedDim = typeof EMBED_DIM !== 'undefined' ? EMBED_DIM : 8;
            const neuronsPerLayer = [embedDim, ...Array(qbnn.numLayers).fill(4), 2];
            
            // æ¸¬å®šçµæœãŒãªã„å ´åˆã¯åˆæœŸåŒ–
            if (neuronMeasurements.length === 0) {
                measureAllNeurons();
            }
            
            // æ¥ç¶šã‚’æç”»ï¼ˆã‚¨ãƒ³ã‚¿ãƒ³ã‚°ãƒ«ãƒ¡ãƒ³ãƒˆ = ç™½è‰²ã®æ¿ƒã•ï¼‰
            for (let l = 0; l < numLayers - 1; l++) {
                const x1 = layerSpacing * (l + 1);
                const x2 = layerSpacing * (l + 2);
                
                for (let i = 0; i < neuronsPerLayer[l]; i++) {
                    const y1 = height / (neuronsPerLayer[l] + 1) * (i + 1);
                    
                    for (let j = 0; j < neuronsPerLayer[l + 1]; j++) {
                        const y2 = height / (neuronsPerLayer[l + 1] + 1) * (j + 1);
                        
                        // ã‚¨ãƒ³ã‚¿ãƒ³ã‚°ãƒ«ãƒ¡ãƒ³ãƒˆå¼·åº¦ã‚’è¨ˆç®—
                        let entangleStrength = 0.1;
                        if (l > 0 && l <= qbnn.numLayers) {
                            entangleStrength = qbnn.layers[l - 1].entangleStrength;
                        } else if (l === 0 && qbnn.layers.length > 0) {
                            entangleStrength = qbnn.layers[0].entangleStrength * 0.5;
                        }
                        
                        // ã‚‚ã¤ã‚Œã®å¼·ã•ã«å¿œã˜ã¦ç™½è‰²ã®æ¿ƒã•ã‚’å¤‰ãˆã‚‹
                        const whiteIntensity = Math.floor(100 + entangleStrength * 155);
                        const alpha = 0.3 + entangleStrength * 0.7;
                        
                        ctx.strokeStyle = `rgba(${whiteIntensity}, ${whiteIntensity}, ${whiteIntensity + 50}, ${alpha})`;
                        ctx.lineWidth = 1 + entangleStrength * 2;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }
            }
            
            // ãƒ‹ãƒ¥ãƒ¼ãƒ­ãƒ³ã‚’æç”»ï¼ˆæ¸¬å®šçµæœ 0/1 è¡¨ç¤ºï¼‰
            for (let l = 0; l < numLayers; l++) {
                const x = layerSpacing * (l + 1);
                
                for (let i = 0; i < neuronsPerLayer[l]; i++) {
                    const y = height / (neuronsPerLayer[l] + 1) * (i + 1);
                    
                    // æ¸¬å®šçµæœ
                    const measurement = neuronMeasurements[l] ? neuronMeasurements[l][i] : 0;
                    
                    // æ¸¬å®šçµæœã«å¿œã˜ãŸè‰²ï¼ˆ1=æ˜ã‚‹ã„ã€0=æš—ã„ï¼‰
                    let bgColor, textColor;
                    if (measurement === 1) {
                        bgColor = 'rgba(100, 200, 255, 0.9)';  // æ˜ã‚‹ã„é’
                        textColor = '#000';
                    } else {
                        bgColor = 'rgba(40, 40, 80, 0.9)';  // æš—ã„
                        textColor = '#aaa';
                    }
                    
                    // ãƒ‹ãƒ¥ãƒ¼ãƒ­ãƒ³å††
                    ctx.fillStyle = bgColor;
                    ctx.beginPath();
                    ctx.arc(x, y, 18, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // æ ç·š
                    ctx.strokeStyle = measurement === 1 ? 
                        'rgba(150, 220, 255, 1)' : 'rgba(80, 80, 120, 0.8)';
                    ctx.lineWidth = measurement === 1 ? 3 : 2;
                    ctx.stroke();
                    
                    // æ¸¬å®šçµæœãƒ†ã‚­ã‚¹ãƒˆï¼ˆ0 or 1ï¼‰
                    ctx.fillStyle = textColor;
                    ctx.font = 'bold 14px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(measurement.toString(), x, y);
                }
                
                // ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ©ãƒ™ãƒ«
                ctx.fillStyle = '#888';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'alphabetic';
                
                let label;
                if (l === 0) label = 'Input';
                else if (l === numLayers - 1) label = 'Output';
                else label = `Layer ${l - 1}`;
                
                ctx.fillText(label, layerSpacing * (l + 1), height - 10);
            }
            
            // ã‚¨ãƒ³ã‚¿ãƒ³ã‚°ãƒ«ãƒ¡ãƒ³ãƒˆå¼·åº¦ã®å‡¡ä¾‹
            ctx.fillStyle = '#666';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('ã‚¨ãƒ³ã‚¿ãƒ³ã‚°ãƒ«ãƒ¡ãƒ³ãƒˆ: æ¿ƒã„ç·š = å¼·ã„ã‚‚ã¤ã‚Œ', 10, 15);
        }
        
        function drawBlochSphere() {
            const canvas = document.getElementById('bloch-canvas');
            const ctx = canvas.getContext('2d');
            
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * 2;
            canvas.height = rect.height * 2;
            ctx.scale(2, 2);
            
            const width = rect.width;
            const height = rect.height;
            const cx = width / 2;
            const cy = height / 2;
            const radius = Math.min(width, height) / 2 - 40;
            
            // èƒŒæ™¯ã‚¯ãƒªã‚¢
            ctx.fillStyle = 'rgba(0, 0, 20, 0.5)';
            ctx.fillRect(0, 0, width, height);
            
            // çƒä½“ã‚’æç”»ï¼ˆãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰
            ctx.strokeStyle = 'rgba(100, 100, 150, 0.3)';
            ctx.lineWidth = 1;
            
            // æ°´å¹³å††
            for (let lat = -60; lat <= 60; lat += 30) {
                const r = radius * Math.cos(lat * Math.PI / 180);
                const y = cy + radius * Math.sin(lat * Math.PI / 180) * 0.3;
                
                ctx.beginPath();
                ctx.ellipse(cx, y, r, r * 0.3, 0, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // å‚ç›´å††
            ctx.beginPath();
            ctx.ellipse(cx, cy, radius, radius, 0, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.ellipse(cx, cy, radius * 0.3, radius, 0, 0, Math.PI * 2);
            ctx.stroke();
            
            // è»¸
            ctx.strokeStyle = 'rgba(150, 150, 200, 0.5)';
            ctx.setLineDash([5, 5]);
            
            // Zè»¸
            ctx.beginPath();
            ctx.moveTo(cx, cy - radius);
            ctx.lineTo(cx, cy + radius);
            ctx.stroke();
            
            // Xè»¸
            ctx.beginPath();
            ctx.moveTo(cx - radius, cy);
            ctx.lineTo(cx + radius, cy);
            ctx.stroke();
            
            ctx.setLineDash([]);
            
            // é¸æŠã•ã‚ŒãŸãƒ¬ã‚¤ãƒ¤ãƒ¼ã®çŠ¶æ…‹ãƒ™ã‚¯ãƒˆãƒ«
            if (qbnn.layers[selectedLayerIndex]) {
                const layer = qbnn.layers[selectedLayerIndex];
                const theta = layer.theta;
                
                // Blochçƒä¸Šã®åº§æ¨™
                const bx = Math.sin(2 * theta);
                const bz = Math.cos(2 * theta);
                
                const px = cx + bx * radius;
                const py = cy - bz * radius;
                
                // ãƒ™ã‚¯ãƒˆãƒ«
                ctx.strokeStyle = '#ff6666';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.lineTo(px, py);
                ctx.stroke();
                
                // çŸ¢å°ã®å…ˆç«¯
                ctx.fillStyle = '#ff6666';
                ctx.beginPath();
                ctx.arc(px, py, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // |0âŸ©, |1âŸ© ãƒ©ãƒ™ãƒ«
                ctx.fillStyle = '#6af';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('|0âŸ©', cx, cy - radius - 15);
                ctx.fillText('|1âŸ©', cx, cy + radius + 20);
                ctx.fillText('x', cx + radius + 15, cy + 5);
            }
        }
        
        function drawRTPlane() {
            const canvas = document.getElementById('rt-canvas');
            const ctx = canvas.getContext('2d');
            
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * 2;
            canvas.height = rect.height * 2;
            ctx.scale(2, 2);
            
            const width = rect.width;
            const height = rect.height;
            const cx = width / 2;
            const cy = height - 30;
            const scale = Math.min(width / 2.5, height - 50);
            
            // èƒŒæ™¯ã‚¯ãƒªã‚¢
            ctx.fillStyle = 'rgba(0, 0, 20, 0.5)';
            ctx.fillRect(0, 0, width, height);
            
            // ã‚°ãƒªãƒƒãƒ‰
            ctx.strokeStyle = 'rgba(100, 100, 150, 0.2)';
            ctx.lineWidth = 1;
            
            for (let i = -1; i <= 1; i += 0.5) {
                ctx.beginPath();
                ctx.moveTo(cx + i * scale, 20);
                ctx.lineTo(cx + i * scale, cy);
                ctx.stroke();
            }
            
            for (let i = 0; i <= 1; i += 0.25) {
                ctx.beginPath();
                ctx.moveTo(cx - scale, cy - i * scale);
                ctx.lineTo(cx + scale, cy - i * scale);
                ctx.stroke();
            }
            
            // åˆ¶ç´„æ›²ç·š rÂ² + TÂ² = 1
            ctx.strokeStyle = '#6af';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let theta = 0; theta <= Math.PI / 2; theta += 0.01) {
                const r = Math.cos(2 * theta);
                const T = Math.abs(Math.sin(2 * theta));
                const x = cx + r * scale;
                const y = cy - T * scale;
                
                if (theta === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // å„ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç‚¹
            const colors = ['#ff6666', '#66ff66', '#6666ff', '#ffff66', '#ff66ff'];
            
            qbnn.layers.forEach((layer, i) => {
                const x = cx + layer.r * scale;
                const y = cy - layer.T * scale;
                
                ctx.fillStyle = colors[i % colors.length];
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#fff';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(i.toString(), x, y + 4);
            });
            
            // è»¸ãƒ©ãƒ™ãƒ«
            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('r (correlation)', cx, cy + 25);
            
            ctx.save();
            ctx.translate(15, cy / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('T (temperature)', 0, 0);
            ctx.restore();
        }
        
        // ========================================
        // UIæ›´æ–°
        // ========================================
        
        function updateUI() {
            const stats = qbnn.getStats();
            
            // çµ±è¨ˆæ›´æ–°
            document.getElementById('total-constraint').textContent = 
                stats.totalConstraint.toFixed(4);
            document.getElementById('avg-r').textContent = 
                stats.avgR.toFixed(3);
            document.getElementById('avg-T').textContent = 
                stats.avgT.toFixed(3);
            
            // ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡Œæ›´æ–°
            const rowsContainer = document.getElementById('layer-rows');
            rowsContainer.innerHTML = '';
            
            qbnn.layers.forEach((layer, i) => {
                const constraint = APQB.constraint(layer.theta);
                const row = document.createElement('div');
                row.className = 'layer-row';
                row.innerHTML = `
                    <span>Layer ${i}</span>
                    <span>${layer.theta.toFixed(3)}</span>
                    <span style="color: ${layer.r > 0 ? '#6af' : '#f66'}">${layer.r.toFixed(3)}</span>
                    <span>${layer.T.toFixed(3)}</span>
                    <span style="color: ${Math.abs(constraint - 1) < 0.01 ? '#6f6' : '#f66'}">${constraint.toFixed(4)}</span>
                `;
                rowsContainer.appendChild(row);
            });
            
            // é‡å­çŠ¶æ…‹è¡¨ç¤º
            if (qbnn.layers[selectedLayerIndex]) {
                const layer = qbnn.layers[selectedLayerIndex];
                document.getElementById('amp-0').textContent = 
                    `cos(Î¸) = ${Math.cos(layer.theta).toFixed(3)}`;
                document.getElementById('amp-1').textContent = 
                    `sin(Î¸) = ${Math.sin(layer.theta).toFixed(3)}`;
            }
        }
        
        function updateLayerSelector() {
            const slider = document.getElementById('selected-layer');
            slider.max = qbnn.numLayers - 1;
            if (selectedLayerIndex >= qbnn.numLayers) {
                selectedLayerIndex = qbnn.numLayers - 1;
                slider.value = selectedLayerIndex;
            }
            document.getElementById('selected-layer-val').textContent = 
                `Layer ${selectedLayerIndex}`;
        }
        
        // ========================================
        // ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆ
        // ========================================
        
        function generateText() {
            const prompt = document.getElementById('prompt-input').value || 'é‡å­';
            const temperature = document.getElementById('temperature').value / 100;
            const length = parseInt(document.getElementById('gen-length').value);
            
            let output = prompt;
            const outputBox = document.getElementById('output-box');
            outputBox.textContent = 'ç”Ÿæˆä¸­...';
            outputBox.classList.add('quantum-active');
            
            // éåŒæœŸã§ç”Ÿæˆ
            setTimeout(() => {
                for (let i = 0; i < length; i++) {
                    // QBNNã‚’é€šé
                    qbnn.forward();
                    
                    // é‡å­æ¸¬å®šã§æ¬¡ã®å˜èªã‚’é¸æŠ
                    const lastLayer = qbnn.layers[qbnn.layers.length - 1];
                    const p = (1 + lastLayer.r) / 2;
                    
                    // æ¸©åº¦ã«å¿œã˜ãŸã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
                    let idx = Math.floor(Math.random() * vocabulary.length);
                    
                    // é‡å­åŠ¹æœã‚’è¿½åŠ 
                    const quantum_noise = APQB.measure(lastLayer.theta) * 0.1;
                    idx = Math.floor((idx + quantum_noise * vocabulary.length) % vocabulary.length);
                    
                    output += vocabulary[idx];
                    
                    // å±¤ã‚’å°‘ã—å¤‰åŒ–ã•ã›ã‚‹
                    qbnn.layers.forEach(layer => {
                        layer.theta += (Math.random() - 0.5) * 0.1 * temperature;
                        layer.theta = Math.max(0, Math.min(Math.PI / 2, layer.theta));
                        layer.r = APQB.thetaToR(layer.theta);
                        layer.T = APQB.thetaToT(layer.theta);
                    });
                }
                
                outputBox.textContent = output;
                outputBox.classList.remove('quantum-active');
                
                updateUI();
                drawNetwork();
                drawBlochSphere();
                drawRTPlane();
            }, 100);
        }
        
        // ========================================
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        // ========================================
        
        document.getElementById('num-layers').addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            document.getElementById('num-layers-val').textContent = val;
            qbnn = new EQBNN(val, qbnn.entangleStrength);
            updateLayerSelector();
            updateUI();
            drawNetwork();
            drawBlochSphere();
            drawRTPlane();
        });
        
        document.getElementById('entangle-strength').addEventListener('input', (e) => {
            const val = e.target.value / 100;
            document.getElementById('entangle-val').textContent = val.toFixed(2);
            qbnn.entangleStrength = val;
            qbnn.layers.forEach((layer, i) => {
                layer.entangleStrength = val * (1 - i * 0.1);
            });
            updateUI();
            drawNetwork();
        });
        
        document.getElementById('selected-layer').addEventListener('input', (e) => {
            selectedLayerIndex = parseInt(e.target.value);
            document.getElementById('selected-layer-val').textContent = 
                `Layer ${selectedLayerIndex}`;
            updateUI();
            drawBlochSphere();
        });
        
        document.getElementById('temperature').addEventListener('input', (e) => {
            document.getElementById('temp-val').textContent = 
                (e.target.value / 100).toFixed(2);
        });
        
        document.getElementById('gen-length').addEventListener('input', (e) => {
            document.getElementById('len-val').textContent = e.target.value;
        });
        
        // ========================================
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
        // ========================================
        
        function animate() {
            // 2Î¸ ãŒ 45Â°ã€œ135Â° ã®ç¯„å›² â†’ Î¸ ã¯ Ï€/8ã€œ3Ï€/8 ã®ç¯„å›²
            const thetaMin = Math.PI / 8;   // 22.5Â°
            const thetaMax = 3 * Math.PI / 8; // 67.5Â°
            const thetaCenter = Math.PI / 4;  // 45Â° (ä¸­å¤®)
            
            qbnn.layers.forEach(layer => {
                // é‡å­æºã‚‰ã
                const fluctuation = (Math.random() - 0.5) * 0.008;
                layer.theta += fluctuation;
                
                // ä¸­å¤®å€¤ã«å‘ã‹ã†å¼±ã„å¾©å…ƒåŠ›
                const restoring = (thetaCenter - layer.theta) * 0.005;
                layer.theta += restoring;
                
                // ç¯„å›²ã‚’ 2Î¸ = 45Â°ã€œ135Â° ã«åˆ¶é™
                layer.theta = Math.max(thetaMin, Math.min(thetaMax, layer.theta));
                layer.r = APQB.thetaToR(layer.theta);
                layer.T = APQB.thetaToT(layer.theta);
            });
            
            qbnn.forward();
            
            updateUI();
            drawNetwork();
            drawBlochSphere();
            drawRTPlane();
            
            animationId = requestAnimationFrame(animate);
        }
        
        // ========================================
        // åˆæœŸåŒ–
        // ========================================
        
        window.addEventListener('load', () => {
            updateLayerSelector();
            updateUI();
            drawNetwork();
            drawBlochSphere();
            drawRTPlane();
            
            // åˆæœŸã‚¨ãƒ³ãƒ™ãƒ‡ã‚£ãƒ³ã‚°è¨ˆç®—
            computeEmbedding();
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
            animate();
        });
        
        window.addEventListener('resize', () => {
            drawNetwork();
            drawBlochSphere();
            drawRTPlane();
        });
    </script>
</body>
</html>

